1. В текущей реализации порядок добавления GameObject в общий список может влиять на логику игры, например, сначала игрок передвигается, после проверяет столкновения, а только после двигаются противники. Можно ли этого избежать?
	Согласен, текущая реализция имеет такую проблему, упустил этот момент. Подумав, решение вижу следующее - на уровне IGameState орагнизовать массивы компонентов, по массиву на каждый тип компонента (массив AI компонентов, Render компонентов и т.п.). Так мы сможем контролировать порядок обновления компонентов, например сначала перемещать все объекты, потом просчитывать столкновения и в конце отрисовывать объекты. Плюсом этого подхода так же вижу еще то, что мы будем обращаться сразу к компонентам, а не сначала к GameObject и только потом к компоненам, что должно несколько ускорить просчет обновлений. Но при этом GameObjects все равно должны ссылаться на свои компоненты, чтобы была возможность взаимодействия компонентов между собой. 
	
2. Как реализовать переключение RenderModes во время игры?
	Исходя из ответа на вопрос 1, решение вижу следующее - Добавить к компонентам свойство активен\неактивен. Реализовать сортировку компоеннтов в массивах, чтобы сначала шли те которые активны, следом неактивные. Таким образом, мы сможем обращаться только к перым N Элементам(они активны), и не затрагивать неактивные. При изменении типа рендера активировать компоненты для рендера выбранного типа и деактивировать другого типа. При активации\деактивации изменять расположение компонента в массиве, и увеличивать\уменьшать счетчик активных компоеннтов.
	В текущей реализции можно добавить оба компонента, которые отвечают за рендер, в GameObject. А непосредсвтенно в самих компонентах проверять тип, который выбран, но я не хотел добавлять эту логику непосредственно в реализацию компонентов. 
	
3. Почему IComponent содержит метод Render? Большая часть компонентов его не реализует.
	Добавлен с целью универсализации компонентов. Так как в OpenGL используется два разных метода для обновления логики и рендера, пришлось добавить этот метод в IComponent, для того чтобы разделить логикуотрисовки и обновления логики и была возможность пройтись по коллекции компонентов в объекте, не выделяя только те которые относятся к render. Исходя из ответа на вопрос 1, можно было бы убрать этот метод из IComponent, и реализовать логику рендера в методое Update.
	
4. Почему коллекции SandboxGameState.GameObjects и GameObject._components List?
	Не подумал перед выбором, а так же над оптимизацией этого момента. Можно оптимизировать, выбрав более подходящий тип, в котором операции удаления объектов из списка будут выполняться быстрее. 
	
5. Почему StateManager static class? Какие преимущества и недостатки у этого решения?
	Это не используемый класс(забыл удалить из проекта). Было решено отказаться от такой реализации. Нам не нужно хранить постоянно все существующие GameState и получать к ним доступ. InputManager и Renderer являются статичными, так как экземпляры этих классов не нужны, состояния они ниакие не хранят, и их инструменты используются в различных местах. Недостатки - нельзя наследоваться от таких классов, и создавать экземпляры.
	

	